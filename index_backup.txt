require("dotenv").config();
const express = require("express");
const mysql = require("mysql");
const http = require("http");
const cors = require("cors");
const session = require("express-session");
const axios = require("axios");
const helmet = require("helmet");
const { MercadoPagoConfig, Preference } = require("mercadopago");
const bcrypt = require("bcrypt");
const path = require("path"); 

const app = express();
const PORT = process.env.PORT || 3030;
// Normalizar BASE_URL: asegurar que incluya protocolo (https por defecto)
let BASE_URL = process.env.BASE_URL || '';
if (BASE_URL && !/^https?:\/\//i.test(BASE_URL)) {
  BASE_URL = 'https://' + BASE_URL;
}
// Log inicial para asegurar que el proceso llega hasta aquÃ­
console.log('ðŸ”§ Iniciando aplicaciÃ³n (NODE_ENV=' + (process.env.NODE_ENV || 'development') + ')');
console.log('ðŸ”§ Cargando variables de entorno relevantes: PORT=' + PORT + ', BASE_URL=' + BASE_URL);

// Manejo global de errores no capturados para que no se silencien los fallos
process.on('uncaughtException', (err) => {
  console.error('ðŸ’¥ ExcepciÃ³n no capturada:', err && err.stack ? err.stack : err);
  // En desarrollo no terminar inmediatamente para poder leer el log, en producciÃ³n podrÃ­as process.exit(1)
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('ðŸ’¥ Rechazo de promesa no manejado:', reason);
});
const bodyParser = require('body-parser');

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());


// ----------------- ConexiÃ³n a la DB -----------------
let conexion = mysql.createConnection({
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASS,
  port: process.env.DB_PORT
});

// ConexiÃ³n a la base de datos con reintento y manejo de errores explÃ­cito
const connectWithRetry = () => {
  // Crear una nueva instancia de conexiÃ³n en cada intento para evitar estados fatales
  conexion = mysql.createConnection({
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    user: process.env.DB_USER,
    password: process.env.DB_PASS,
    port: process.env.DB_PORT
  });

  conexion.connect(err => {
    if (err) {
      // No lanzar excepciÃ³n no capturada; en su lugar loguear y reintentar
      console.error('âŒ Error conectando a MySQL:', err && err.code ? err.code : err.message || err);
      console.error('âž¡ï¸ Comprueba que el servicio de MySQL estÃ¡ en ejecuciÃ³n, que el puerto es correcto y las credenciales en .env son vÃ¡lidas.');
      console.error(`   DB_HOST=${process.env.DB_HOST}, DB_PORT=${process.env.DB_PORT}, DB_USER=${process.env.DB_USER}, DB_NAME=${process.env.DB_NAME}`);
      // Cerrar la conexiÃ³n fallida si existe
      try { conexion.destroy(); } catch (e) { /* ignore */ }
      // Re-intentar despuÃ©s de 5 segundos
      setTimeout(connectWithRetry, 5000);
      return;
    }
    console.log("ðŸŸ¢ Conectado a la base de datos");
  });

  // Manejar errores en la conexiÃ³n y permitir reintentos
  conexion.on('error', (err) => {
    console.error('ðŸ’¥ Error en conexiÃ³n MySQL (evento):', err && err.code ? err.code : err.message || err);
    if (err && (err.code === 'PROTOCOL_CONNECTION_LOST' || err.fatal)) {
      // Reintentar conexiÃ³n
      console.log('ðŸ” Reintentando conexiÃ³n a MySQL...');
      setTimeout(connectWithRetry, 2000);
    }
  });
};

connectWithRetry();

// ----------------- Middlewares -----------------
// Helmet con Content Security Policy personalizada
// Permitimos temporalmente algunos orÃ­genes y 'unsafe-inline' para facilitar pruebas
// Nota: en producciÃ³n conviene eliminar 'unsafe-inline' y usar nonces/ hashes o mover eventos inline a JS.
const helmetOptions = {
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", 'https://kit.fontawesome.com', "'unsafe-inline'"],
      // Permitir atributos inline (onclick) temporalmente
      scriptSrcAttr: ["'unsafe-inline'"],
      scriptSrcElem: ["'self'", 'https://kit.fontawesome.com'],
      styleSrc: ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
      fontSrc: ["'self'", 'https://fonts.gstatic.com'],
      imgSrc: ["'self'", 'data:'],
      connectSrc: ["'self'", BASE_URL || "'self'"],
      objectSrc: ["'none'"],
      baseUri: ["'self'"],
    }
  }
};
app.use(helmet(helmetOptions));
app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));
app.use(express.json({ limit: "10kb" }));
app.use(express.urlencoded({ extended: false }));
// Servir correctamente la carpeta de JS en /js
app.use('/js', express.static(path.join(__dirname, 'views', 'js')));
// ConfiguraciÃ³n de sesiÃ³n mejorada para ngrok
app.enable('trust proxy'); // Necesario para HTTPS detrÃ¡s de proxy
app.use(session({
    secret: process.env.SESSION_SECRET || 'tu-secreto-seguro',
    name: 'sessionId', // Cambiamos el nombre de la cookie
    resave: false,
    saveUninitialized: false,
    rolling: true,
    proxy: true,
    cookie: {
        secure: true,
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000,
        sameSite: 'none',
        path: '/'
    }
}));

// ConfiguraciÃ³n de CORS mejorada: permitir localhost y la URL pÃºblica (ngrok) dinÃ¡mica
const allowedOrigins = [ 'http://localhost:3030' ];
if (BASE_URL) allowedOrigins.push(BASE_URL);

app.use(cors({ 
  origin: function(origin, callback) {
    // origin puede ser undefined en herramientas como curl/postman o en same-origin requests
    if (!origin) return callback(null, true);

    // OrÃ­genes permitidos exactos
    if (allowedOrigins.indexOf(origin) !== -1) return callback(null, true);

    // Permitir si el origin empieza por BASE_URL (Ãºtil para ngrok/puertos probabilÃ­sticos)
    if (BASE_URL && origin.startsWith(BASE_URL)) return callback(null, true);

    // En desarrollo, ser permisivo para facilitar pruebas desde dispositivos mÃ³viles
    if ((process.env.NODE_ENV || 'development') !== 'production') {
      console.warn('âš ï¸ CORS DEV: permitiendo origen no listado ->', origin);
      return callback(null, true);
    }

    console.warn('âš ï¸ CORS: origen no permitido ->', origin);
    return callback(new Error('CORS origin not allowed'));
  },
  credentials: true,
  methods: ['GET', 'POST'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Middleware de debug mejorado
app.use((req, res, next) => {
  console.log('ðŸ“Š Debug Request:', {
    path: req.path,
    cookies: req.headers.cookie,
    secure: req.secure,
    protocol: req.protocol,
    hostname: req.hostname,
    originalUrl: req.originalUrl,
    sessionID: req.sessionID,
    session: {
      id: req.session?.id,
      usuarioID: req.session?.usuarioID,
      cookie: req.session?.cookie
    }
  });
  next();
});

// Middleware para mantener y verificar la sesiÃ³n
app.use((req, res, next) => {
    console.log('ðŸ›£ï¸ Ruta:', req.path);
    console.log('ðŸ‘¤ Session ID:', req.sessionID);
    console.log('ðŸ”‘ Usuario ID:', req.session?.usuarioID);
    
    // Guardar la sesiÃ³n en cada request para mantenerla activa
    if (req.session?.usuarioID) {
        req.session.touch();
        req.session.save((err) => {
            if (err) console.error('Error al guardar sesiÃ³n:', err);
            next();
        });
    } else {
        next();
    }
});

// Rutas estÃ¡ticas - no necesitan sesiÃ³n
const staticOptions = {
    etag: true,
    lastModified: true,
    setHeaders: (res, path) => {
        res.setHeader('Cache-Control', 'public, max-age=3600');
    }
};

app.use("/css", express.static(__dirname + "/views/css", staticOptions));
app.use("/imagenes", express.static(__dirname + "/views/imagenes", staticOptions));
app.use(express.static(path.join(__dirname, 'views'), staticOptions));

// Middleware para verificar sesiÃ³n en rutas protegidas
const verificarSesion = (req, res, next) => {
    if (!req.session?.usuarioID) {
        console.log('âŒ Acceso denegado: no hay sesiÃ³n');
        return res.redirect('/login');
    }
    console.log('âœ… SesiÃ³n verificada para usuario:', req.session.usuarioID);
    next();
};

// Rutas protegidas que requieren sesiÃ³n
app.get("/cursos", verificarSesion, (req, res) => {
    console.log('ðŸŽ“ Mostrando cursos para usuario:', req.session.usuarioID);
    res.render("cursos", { 
        usuarioID: req.session.usuarioID,
        usuario: req.session.usuario
    });
});
app.get("/login", (req, res) => {
  // Si ya hay sesiÃ³n, redirigir a index1
  if (req.session?.usuarioID) {
    console.log('ðŸ‘¤ Usuario ya logueado, redirigiendo a index1');
    return res.redirect('/index1');
  }
  console.log('ðŸ“ Mostrando pÃ¡gina de login');
  res.render("login");
});
app.get("/registro", (req, res) => {
  res.render("registro");
});
app.get("/carrito", (req, res) => {
  if (!req.session.usuarioID || req.session.rol !== "usuario") return res.redirect("/login.ejs");
  res.render("carrito", { usuarioID: req.session.usuarioID });
}
);  
app.get("/perfil", (req, res) => {
  if (!req.session.usuarioID || req.session.rol !== "usuario") return res.redirect("/login.ejs");
  res.render("perfil", { usuarioID: req.session.usuarioID });
}
);
app.get("/sobremi", (req, res) => {
    res.render("sobremi");
});

app.get("/contacto", (req, res) => {
    res.render("contacto");
});

app.get("/servicios", (req, res) => {
    res.render("servicios");
});

// ----------------- Rutas -----------------
app.get("/", (req, res) => {
    // Si hay sesiÃ³n, ir a index1, si no a login
    if (req.session?.usuarioID) {
        console.log('ðŸ‘¤ Usuario logueado, redirigiendo a index1');
        return res.redirect('/index1');
    }
    console.log('ðŸ“ Redirigiendo a login');
    res.redirect('/login');
});

app.get("/index1", (req, res) => {
    // Verificar si hay sesiÃ³n
    if (!req.session?.usuarioID) {
        console.log('âŒ No hay sesiÃ³n, redirigiendo a login');
        return res.redirect('/login');
    }
    console.log('âœ… Mostrando index1 para usuario:', req.session.usuarioID);
    res.render("index1");
});

// ----------------- Login y registro -----------------
// ----------------- Login y Registro (con bcrypt) -----------------

// Iniciar sesiÃ³n
app.post("/iniciar", async (req, res) => {
    console.log('ðŸ”‘ Intento de inicio de sesiÃ³n');
    const { usuarioIng, contrasenaIng } = req.body;

    try {
        if (!usuarioIng || !contrasenaIng) {
            console.log('âŒ Faltan datos de inicio de sesiÃ³n');
            return res.status(400).send("Falta usuario o contraseÃ±a");
        }

        const consultaUsuario = "SELECT * FROM usuario WHERE NOMBRE = ?";
        conexion.query(consultaUsuario, [usuarioIng], async (error, resultadoUsuario) => {
            if (error) {
                console.error("âŒ Error en consulta:", error);
                return res.status(500).send("Error del servidor");
            }

            if (resultadoUsuario.length === 0) {
                console.log('âŒ Usuario no encontrado:', usuarioIng);
                return res.status(401).send("Usuario no encontrado");
            }

            const usuario = resultadoUsuario[0];
            const esValida = await bcrypt.compare(contrasenaIng, usuario.CONTRASENIA);

            if (!esValida) {
                console.log('âŒ ContraseÃ±a incorrecta para usuario:', usuarioIng);
                return res.status(401).send("ContraseÃ±a incorrecta");
            }

            // Establecer la sesiÃ³n directamente
            req.session.usuarioID = usuario.ID_USUARIO;
            req.session.rol = "usuario";
            req.session.usuario = usuario.NOMBRE;
            
            // Forzar guardado de sesiÃ³n
            await new Promise((resolve, reject) => {
                req.session.save((err) => {
                    if (err) {
                        console.error("âŒ Error al guardar sesiÃ³n:", err);
                        reject(err);
                    } else {
                        resolve();
                    }
                });
            });
            
            console.log("âœ… SesiÃ³n iniciada para usuario:", {
                id: req.sessionID,
                usuarioID: usuario.ID_USUARIO,
                nombre: usuario.NOMBRE,
                cookie: req.session.cookie
            });
            
            // Enviar las cookies antes de redirigir
            res.setHeader('Cache-Control', 'no-store');
            res.setHeader('Pragma', 'no-cache');
            
            return res.redirect("/index1");
        });
    } catch (err) {
        console.error("âŒ Error general:", err);
        res.status(500).send("Error del servidor");
    }
});

// Registrar nuevo usuario
app.post("/registrar", async (req, res) => {
  const { nombre, apellido, DNI, correo, telefono, contrasena } = req.body;

  if (!nombre || !apellido || !DNI || !correo || !telefono || !contrasena) {
    return res.status(400).send("Faltan datos en el registro");
  }

  try {
    // Verificar si el usuario o DNI ya existen
    const verificarUsuario = "SELECT * FROM usuario WHERE DNI = ? OR NOMBRE = ?";
    conexion.query(verificarUsuario, [DNI, correo], async (error, resultado) => {
      if (error) {
        console.error("âŒ Error al verificar usuario:", error);
        return res.status(500).send("Error al verificar usuario");
      }

      if (resultado.length > 0) {
        return res.status(409).send("El usuario o DNI ya estÃ¡n registrados");
      }

      // Generar hash seguro con bcrypt
      const hash = await bcrypt.hash(contrasena, 10);

      // Insertar en tabla persona
      const registrarPersona = `
        INSERT INTO persona (DNI, NOMBRE, APELLIDO, EMAIL, TELEFONO)
        VALUES (?, ?, ?, ?, ?)
      `;
      conexion.query(registrarPersona, [DNI, nombre, apellido, correo, telefono], (errorPersona) => {
        if (errorPersona) {
          console.error("âŒ Error al registrar persona:", errorPersona);
          return res.status(500).send("Error al registrar persona");
        }

        // Insertar en tabla usuario con contraseÃ±a hasheada
        const registrarUsuario = `
          INSERT INTO usuario (DNI, NOMBRE, CONTRASENIA)
          VALUES (?, ?, ?)
        `;
        conexion.query(registrarUsuario, [DNI, correo, hash], (errorUsuario) => {
          if (errorUsuario) {
            console.error("âŒ Error al registrar usuario:", errorUsuario);
            return res.status(500).send("Error al registrar usuario");
          }

          console.log(`âœ… Usuario ${correo} registrado correctamente`);
          return res.send("usuario registrado con exito preciona f5 para volver"); 
        });
      });
    });
  } catch (err) {
    console.error("âŒ Error general en registro:", err);
    res.status(500).send("Error interno del servidor");
  }
});

app.get("/logout", (req, res) => {
  req.session.destroy(err => {
    if (err) return res.status(500).send("Error al cerrar sesiÃ³n");
    res.redirect("/login.ejs");
  });
});

// Ruta de desarrollo: setea sesiÃ³n para pruebas rÃ¡pidas (SOLO en desarrollo)
if ((process.env.NODE_ENV || 'development') !== 'production') {
  app.get('/dev-login', (req, res) => {
    const id = Number(req.query.id || 5);
    req.session.usuarioID = id;
    req.session.usuario = { nombre: 'Dev User ' + id };
    req.session.save(err => {
      if (err) {
        console.error('Error al guardar sesiÃ³n en /dev-login:', err);
        return res.status(500).json({ ok: false, error: 'session-save-failed' });
      }
      console.log('ðŸ”§ /dev-login: sesiÃ³n creada para usuario', id);
      return res.json({ ok: true, usuarioID: id });
    });
  });
}

// ----------------- ConfiguraciÃ³n Mercado Pago-----------------
app.get("/configMercadoPago", (req, res) => {
  try {
  // no need to configure here; just return the public key
  res.json({ publicKey: process.env.MP_PUBLIC_KEY });
  } catch (error) {
    console.error("Error en configuraciÃ³n MP:", error);
    res.status(500).send("Error en configuraciÃ³n de MercadoPago");
  }
});

// Endpoint para generar preferencia de pago
// Middleware para verificar los datos necesarios para el pago
const verificarDatosPago = (req, res, next) => {
    if (!process.env.MP_ACCESS_TOKEN || !process.env.MP_PUBLIC_KEY) {
        console.error('âŒ Error: Faltan credenciales de MercadoPago');
        return res.status(500).send('Error de configuraciÃ³n del servidor');
    }
    if (!process.env.BASE_URL) {
        console.error('âŒ Error: Falta BASE_URL');
        return res.status(500).send('Error de configuraciÃ³n del servidor');
    }
    next();
};

app.get('/generar', verificarDatosPago, async (req, res) => {
    try {
        // VerificaciÃ³n estricta de sesiÃ³n
        const usuarioID = req.session?.usuarioID;
    console.log('ðŸ” Verificando sesiÃ³n en /generar:', {
      sessionID: req.sessionID,
      usuarioID: usuarioID,
      sessionContent: req.session,
      origin: req.headers.origin,
      isAjaxRequest: (req.query.json === '1' || (req.headers.accept || '').includes('application/json'))
    });

    if (!usuarioID) {
      console.log('âŒ Usuario no autenticado en /generar');
      // Si la peticiÃ³n viene desde AJAX/mobile devolver JSON para que el cliente pueda manejarlo
      if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
        return res.status(401).json({ error: 'no-auth', message: 'Usuario no autenticado' });
      }
      return res.redirect('/login');
    }

        const cursoId = req.query.cursoId;
        console.log('ðŸ“¦ Buscando curso:', cursoId);

        let curso = null;

        // Si no se proporciona cursoId, usar curso de prueba
        if (!cursoId) {
            console.log('â„¹ï¸ No se proporcionÃ³ cursoId, usando curso de prueba');
            curso = {
                ID_CURSO: 0,
                NOMBRE_CURSO: 'Curso de prueba',
                PRECIO: 100
            };
        } else {
            try {
                curso = await new Promise((resolve, reject) => {
                    conexion.query(
                        'SELECT ID_CURSO, NOMBRE_CURSO, PRECIO FROM CURSO WHERE ID_CURSO = ?',
                        [cursoId],
                        (err, results) => {
                            if (err) {
                                console.error('âŒ Error en consulta SQL:', err);
                                return reject(err);
                            }
                            if (!results || results.length === 0) {
                                console.log('âš ï¸ No se encontrÃ³ el curso:', cursoId);
                                return resolve(null);
                            }
                            console.log('âœ… Curso encontrado:', results[0]);
                            return resolve(results[0]);
                        }
                    );
                });
            } catch (dbError) {
                console.error('âŒ Error al consultar la base de datos:', dbError);
                return res.status(500).send('Error al buscar el curso');
            }
        }

        // Si no se encontrÃ³ el curso, usar uno de prueba
        if (!curso) {
            console.log('â„¹ï¸ Usando curso de prueba por fallback');
            curso = {
                ID_CURSO: cursoId || 0,
                NOMBRE_CURSO: 'Curso de prueba',
                PRECIO: 100
            };
        }

    // Comprobar si el usuario ya pagÃ³ este curso (evitar pago duplicado)
    try {
      const existePago = await new Promise((resolve, reject) => {
        const sql = `SELECT comp.NUM_OP FROM COMPROBANTE comp JOIN CARRITO c ON comp.ID_CARRITO = c.ID_CARRITO WHERE c.ID_USUARIO = ? AND c.ID_CURSO = ? LIMIT 1`;
        conexion.query(sql, [usuarioID, curso.ID_CURSO], (err, results) => {
          if (err) return reject(err);
          if (!results || results.length === 0) return resolve(null);
          return resolve(results[0]);
        });
      });

      if (existePago) {
        console.log(`âš ï¸ Usuario ${usuarioID} ya pagÃ³ el curso ${curso.ID_CURSO} (op=${existePago.NUM_OP})`);
        if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
          return res.status(409).json({ error: 'already_paid', message: 'Ya pagaste este curso', num_op: existePago.NUM_OP });
        }
        // Para peticiones normales, redirigir a la lista de cursos
        return res.redirect('/cursos');
      }
    } catch (dbCheckErr) {
      console.error('âŒ Error comprobando pagos existentes:', dbCheckErr);
      // No impedir la compra por error en la comprobaciÃ³n; pero loguearlo
    }

    // Si se configurÃ³ un payment link estÃ¡tico (p.ej. link de Mercado Pago), usarlo
    if (process.env.MP_PAYMENT_LINK) {
      const raw = process.env.MP_PAYMENT_LINK;
      const payUrl = raw.startsWith('http') ? raw : `https://${raw}`;
      console.log('â„¹ï¸ Usando MP_PAYMENT_LINK configurado ->', payUrl);
      if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
        return res.json({ init_point: payUrl, id: null });
      }
      return res.redirect(payUrl);
    }

    // Crear cliente y preferencia
        console.log('ðŸ”‘ Usando token:', process.env.MP_ACCESS_TOKEN?.substring(0, 10) + '...');
        
        const client = new MercadoPagoConfig({ 
            accessToken: process.env.MP_ACCESS_TOKEN 
        });

        // Asegurarnos de que el precio sea un nÃºmero
        const precio = Number(curso.PRECIO) || 100;
        console.log('ðŸ’µ Precio del curso:', precio);

        const preference = {
            items: [{
                id: curso.ID_CURSO.toString(),
                title: curso.NOMBRE_CURSO || 'Curso',
                quantity: 1,
                unit_price: precio,
                currency_id: 'ARS',
                description: 'Compra de curso en plataforma'
            }],
            payer: {
                email: 'test_user@example.com',
                name: 'Test User',
                identification: {
                    type: 'DNI',
                    number: '12345678'
                }
            },
            payment_methods: {
                excluded_payment_types: [
                    { id: "ticket" }
                ],
                installments: 1
            },
      // Incluir metadata con el ID de vendedor para que llegue en la notificaciÃ³n
      metadata: {
        seller_id: process.env.MP_MERCHANT_ID || 'unknown'
      },
      back_urls: {
        success: `${BASE_URL}/success`,
        failure: `${BASE_URL}/failure`,
        pending: `${BASE_URL}/pending`
      },
            external_reference: `${usuarioID}-${curso.ID_CURSO}`,
      notification_url: `${BASE_URL}/notificar?usuario=${usuarioID}&curso=${curso.ID_CURSO}`
        };

        console.log('ðŸ’° Generando preferencia:', JSON.stringify(preference, null, 2));

    try {
      const response = await new Preference(client).create({ body: preference });
      console.log('âœ¨ Preferencia creada:', response.id);

      if (!response.init_point) {
        console.error('âŒ La respuesta de MP no incluyÃ³ init_point:', response);
        // Si el cliente esperaba JSON, devolver error JSON
        if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
          return res.status(500).json({ error: 'No se pudo obtener URL de pago desde Mercado Pago' });
        }
        return res.redirect('/failure');
      }

      console.log('ðŸ”— URL de pago:', response.init_point);

      // Soporte para cliente AJAX/mÃ³vil: si se solicita JSON, devolver init_point
      if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
        return res.json({ init_point: response.init_point, id: response.id });
      }

      return res.redirect(response.init_point);
    } catch (mpError) {
      console.error('âŒ Error al crear preferencia:', mpError);
      console.error('Detalles:', mpError.response?.data || mpError.message);
      // Si el request viene desde AJAX/mobile devolver el error en JSON
      if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
        return res.status(500).json({ error: mpError.response?.data || mpError.message });
      }
      // En caso de peticiÃ³n normal redirigir a pÃ¡gina de fallo amigable
      return res.redirect('/failure');
    }

    } catch (error) {
        console.error('âŒ Error:', error);
        res.status(500).send('Error al generar preferencia');
    }
});

app.get('/success', (req, res) => {
  res.send("Pago realizado con Ã©xito");
});

// PÃ¡gina amigable de fallo de pago para evitar el error genÃ©rico de Mercado Pago
app.get('/failure', (req, res) => {
  try {
    return res.render('failure');
  } catch (err) {
    console.error('Error al renderizar /failure:', err);
    return res.status(500).send('Error mostrando la pÃ¡gina de fallo');
  }
});

// Ruta de diagnÃ³stico para verificar el estado del checkout
app.get('/checkout-status', (req, res) => {
  const status = {
    session: {
      active: !!req.session,
      id: req.sessionID,
      usuarioID: req.session?.usuarioID
    },
    headers: {
      origin: req.headers.origin,
      host: req.headers.host,
      cookie: !!req.headers.cookie
    },
    env: {
      baseUrl: !!process.env.BASE_URL,
      mpToken: !!process.env.MP_ACCESS_TOKEN,
      mpPublic: !!process.env.MP_PUBLIC_KEY
    }
  };
  console.log('ðŸ“Š Estado del checkout:', status);
  res.json(status);
});

// Endpoint de diagnÃ³stico para comprobar CORS, cookies y reachability desde el cliente
app.get('/ping', (req, res) => {
  console.log('ðŸ“ /ping recibido desde origin=', req.headers.origin, ' cookies=', req.headers.cookie);
  res.json({ ok: true, origin: req.headers.origin || null, cookies: req.headers.cookie || null, session: { usuarioID: req.session?.usuarioID, rol: req.session?.rol } });
});

app.all('/notificar', async (req, res) => {
  try {
    const query = req.query || {};
    const topic = (query.topic || query.type || '').toString();
    const usuario = query.usuario || query.user || null;
    const curso = query.curso || query.course || null;

    const client = new MercadoPagoConfig({ accessToken: process.env.MP_ACCESS_TOKEN });

    // Helper: evita inserciones duplicadas comprobando COMPROBANTE por NUM_OP
    const comprobanteExiste = async (numOp) => {
      return new Promise((resolve, reject) => {
        conexion.query('SELECT 1 FROM COMPROBANTE WHERE NUM_OP = ? LIMIT 1', [numOp], (err, results) => {
          if (err) return reject(err);
          resolve(Array.isArray(results) && results.length > 0);
        });
      });
    };

    const crearCompra = async (usuarioId, cursoId, numOp) => {
      // Crear carrito
      const carritoId = await new Promise((resolve, reject) => {
        conexion.query(
          'INSERT INTO CARRITO (ID_USUARIO, ID_CURSO, CANTIDAD, FECHACOMPRA) VALUES (?, ?, 1, CURDATE())',
          [usuarioId, cursoId],
          (error, results) => {
            if (error) return reject(error);
            resolve(results.insertId);
          }
        );
      });

      // Crear comprobante
      await new Promise((resolve, reject) => {
        conexion.query(
          'INSERT INTO COMPROBANTE (ID_CARRITO, ID_USUARIO, NUM_OP) VALUES (?, ?, ?)',
          [carritoId, usuarioId, numOp],
          (error) => {
            if (error) return reject(error);
            resolve();
          }
        );
      });
      console.log(`âœ… Compra registrada: usuario=${usuarioId}, curso=${cursoId}, op=${numOp}`);
    };

    // Process payment notifications
    if (topic.includes('payment')) {
      const paymentId = query.id || query['data.id'] || (req.body && (req.body.id || req.body['data.id']));
      if (!paymentId) {
        console.warn('âš ï¸ notificar: payment topic sin id');
        return res.sendStatus(200);
      }

      let paymentInfo;
      try {
        // Usar axios directo a la API de Mercado Pago como fallback
        const resp = await axios.get(`https://api.mercadopago.com/v1/payments/${paymentId}`, {
          headers: { Authorization: `Bearer ${process.env.MP_ACCESS_TOKEN}` }
        });
        paymentInfo = resp.data;
      } catch (err) {
        console.error('âŒ Error consultando pago en MP:', err && err.message ? err.message : err);
        return res.sendStatus(200);
      }

      const status = paymentInfo?.status || paymentInfo?.status_detail;
      console.log('ðŸ“£ notificar payment status =', status);

      if (status === 'approved' || status === 'authorized') {
        if (!usuario || !curso) {
          console.warn('âš ï¸ notificar: faltan usuario o curso en query, no se crea registro');
          return res.sendStatus(200);
        }

        const exists = await comprobanteExiste(paymentId);
        if (exists) {
          console.log('â„¹ï¸ Comprobante ya existe para NUM_OP', paymentId);
          return res.sendStatus(200);
        }

        await crearCompra(usuario, curso, paymentId);
      }

      return res.sendStatus(200);
    }

    // Process merchant_order (puede contener varios pagos)
    if (topic.includes('merchant_order') || topic.includes('merchant')) {
      const orderId = query.id || query['id'] || (req.body && (req.body.id || req.body['data.id']));
      if (!orderId) {
        console.warn('âš ï¸ notificar: merchant_order sin id');
        return res.sendStatus(200);
      }

      let orderInfo;
      try {
        const resp = await axios.get(`https://api.mercadopago.com/merchant_orders/${orderId}`, {
          headers: { Authorization: `Bearer ${process.env.MP_ACCESS_TOKEN}` }
        });
        orderInfo = resp.data;
      } catch (err) {
        console.error('âŒ Error consultando merchant_order en MP:', err && err.message ? err.message : err);
        return res.sendStatus(200);
      }

      const payments = orderInfo?.payments || [];
      for (const p of payments) {
        const pid = p.id || p.payment_id;
        const pst = p.status || p.status_detail || p.status;
        if (pid && (pst === 'approved' || pst === 'authorized')) {
          if (!usuario || !curso) {
            console.warn('âš ï¸ notificar(merchant): faltan usuario o curso en query, no se crea registro');
            continue;
          }
          const exists = await comprobanteExiste(pid);
          if (exists) {
            console.log('â„¹ï¸ Comprobante ya existe para NUM_OP', pid);
            continue;
          }
          await crearCompra(usuario, curso, pid);
        }
      }

      return res.sendStatus(200);
    }

    // Para otros topics, simplemente ACK
    return res.sendStatus(200);
  } catch (error) {
    console.error('âŒ Error en notificaciÃ³n general:', error);
    return res.status(500).send('Error al procesar notificaciÃ³n');
  }
});

// ----------------- Servidor -----------------
http.createServer(app).listen(PORT, () => {
  console.log("ðŸš€ Servidor activo en puerto " + PORT);
});

