require("dotenv").config();
const express = require("express");
const mysql = require("mysql");
const http = require("http");
const cors = require("cors");
const session = require("express-session");
const axios = require("axios");
const helmet = require("helmet");
const { MercadoPagoConfig, Preference } = require("mercadopago");
const bcrypt = require("bcrypt");
const path = require("path"); 
const app = express();
const PORT = process.env.PORT || 3030;
// Normalizar BASE_URL: asegurar que incluya protocolo (https por defecto)
let BASE_URL = process.env.BASE_URL || '';
if (BASE_URL && !/^https?:\/\//i.test(BASE_URL)) {
  BASE_URL = 'https://' + BASE_URL;
}
// Log inicial para asegurar que el proceso llega hasta aquÃ­
console.log('ðŸ”§ Iniciando aplicaciÃ³n (NODE_ENV=' + (process.env.NODE_ENV || 'development') + ')');
console.log('ðŸ”§ Cargando variables de entorno relevantes: PORT=' + PORT + ', BASE_URL=' + BASE_URL);

// Manejo global de errores no capturados para que no se silencien los fallos
process.on('uncaughtException', (err) => {
  console.error('ðŸ’¥ ExcepciÃ³n no capturada:', err && err.stack ? err.stack : err);
  // En desarrollo no terminar inmediatamente para poder leer el log, en producciÃ³n podrÃ­as process.exit(1)
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('ðŸ’¥ Rechazo de promesa no manejado:', reason);
});
const bodyParser = require('body-parser');

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());


// ----------------- ConexiÃ³n a la DB -----------------
let conexion = mysql.createConnection({
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASS,
  port: process.env.DB_PORT
});

// ConexiÃ³n a la base de datos con reintento y manejo de errores explÃ­cito
const connectWithRetry = () => {
  // Crear una nueva instancia de conexiÃ³n en cada intento para evitar estados fatales
  conexion = mysql.createConnection({
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    user: process.env.DB_USER,
    password: process.env.DB_PASS,
    port: process.env.DB_PORT
  });

  conexion.connect(err => {
    if (err) {
      // No lanzar excepciÃ³n no capturada; en su lugar loguear y reintentar
      console.error('âŒ Error conectando a MySQL:', err && err.code ? err.code : err.message || err);
      console.error('âž¡ï¸ Comprueba que el servicio de MySQL estÃ¡ en ejecuciÃ³n, que el puerto es correcto y las credenciales en .env son vÃ¡lidas.');
      console.error(`   DB_HOST=${process.env.DB_HOST}, DB_PORT=${process.env.DB_PORT}, DB_USER=${process.env.DB_USER}, DB_NAME=${process.env.DB_NAME}`);
      // Cerrar la conexiÃ³n fallida si existe
      try { conexion.destroy(); } catch (e) { /* ignore */ }
      // Re-intentar despuÃ©s de 5 segundos
      setTimeout(connectWithRetry, 5000);
      return;
    }
    console.log("ðŸŸ¢ Conectado a la base de datos");
  });

  // Manejar errores en la conexiÃ³n y permitir reintentos
  conexion.on('error', (err) => {
    console.error('ðŸ’¥ Error en conexiÃ³n MySQL (evento):', err && err.code ? err.code : err.message || err);
    if (err && (err.code === 'PROTOCOL_CONNECTION_LOST' || err.fatal)) {
      // Reintentar conexiÃ³n
      console.log('ðŸ” Reintentando conexiÃ³n a MySQL...');
      setTimeout(connectWithRetry, 2000);
    }
  });
};

connectWithRetry();

// ----------------- Middlewares -----------------
// Helmet con Content Security Policy personalizada
// Permitimos temporalmente algunos orÃ­genes y 'unsafe-inline' para facilitar pruebas
// Nota: en producciÃ³n conviene eliminar 'unsafe-inline' y usar nonces/ hashes o mover eventos inline a JS.
const helmetOptions = {
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", 'https://kit.fontawesome.com', "'unsafe-inline'", 'https://player.vimeo.com'],
      // Permitir atributos inline (onclick) temporalmente
      scriptSrcAttr: ["'unsafe-inline'"],
      scriptSrcElem: ["'self'", 'https://kit.fontawesome.com', 'https://player.vimeo.com'],
      styleSrc: ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
      fontSrc: ["'self'", 'https://fonts.gstatic.com'],
      imgSrc: ["'self'", 'data:'],
  connectSrc: ["'self'", BASE_URL || "'self'", 'https://player.vimeo.com'],
  // Permitir iframes de reproductores embebidos (YouTube, YouTube nocookie, Vimeo)
  frameSrc: ["'self'", 'https://www.youtube.com', 'https://www.youtube-nocookie.com', 'https://player.vimeo.com', 'https://vimeo.com', 'https://i.vimeocdn.com'],
  childSrc: ["'self'", 'https://www.youtube.com', 'https://www.youtube-nocookie.com', 'https://player.vimeo.com', 'https://vimeo.com', 'https://i.vimeocdn.com'],
      objectSrc: ["'none'"],
      baseUri: ["'self'"],
    }
  }
};
app.use(helmet(helmetOptions));
app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));
app.use(express.json({ limit: "10kb" }));
app.use(express.urlencoded({ extended: false }));
// Servir correctamente la carpeta de JS en /js
app.use('/js', express.static(path.join(__dirname, 'views', 'js')));
// ConfiguraciÃ³n de sesiÃ³n mejorada para ngrok
app.enable('trust proxy'); // Necesario para HTTPS detrÃ¡s de proxy
app.use(session({
    secret: process.env.SESSION_SECRET || 'tu-secreto-seguro',
    name: 'sessionId', // Cambiamos el nombre de la cookie
    resave: false,
    saveUninitialized: false,
    rolling: true,
    proxy: true,
    cookie: {
        secure: true,
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000,
        sameSite: 'none',
        path: '/'
    }
}));

// ConfiguraciÃ³n de CORS mejorada: permitir localhost y la URL pÃºblica (ngrok) dinÃ¡mica
const allowedOrigins = [ 'http://localhost:3030' ];
if (BASE_URL) allowedOrigins.push(BASE_URL);

app.use(cors({ 
  origin: function(origin, callback) {
    // origin puede ser undefined en herramientas como curl/postman o en same-origin requests
    if (!origin) return callback(null, true);

    // OrÃ­genes permitidos exactos
    if (allowedOrigins.indexOf(origin) !== -1) return callback(null, true);

    // Permitir si el origin empieza por BASE_URL (Ãºtil para ngrok/puertos probabilÃ­sticos)
    if (BASE_URL && origin.startsWith(BASE_URL)) return callback(null, true);

    // En desarrollo, ser permisivo para facilitar pruebas desde dispositivos mÃ³viles
    if ((process.env.NODE_ENV || 'development') !== 'production') {
      console.warn('âš ï¸ CORS DEV: permitiendo origen no listado ->', origin);
      return callback(null, true);
    }

    console.warn('âš ï¸ CORS: origen no permitido ->', origin);
    return callback(new Error('CORS origin not allowed'));
  },
  credentials: true,
  methods: ['GET', 'POST'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Middleware de debug mejorado
app.use((req, res, next) => {
  console.log('ðŸ“Š Debug Request:', {
    path: req.path,
    cookies: req.headers.cookie,
    secure: req.secure,
    protocol: req.protocol,
    hostname: req.hostname,
    originalUrl: req.originalUrl,
    sessionID: req.sessionID,
    session: {
      id: req.session?.id,
      usuarioID: req.session?.usuarioID,
      cookie: req.session?.cookie
    }
  });
  next();
});

// Middleware para mantener y verificar la sesiÃ³n
app.use((req, res, next) => {
    console.log('ðŸ›£ï¸ Ruta:', req.path);
    console.log('ðŸ‘¤ Session ID:', req.sessionID);
    console.log('ðŸ”‘ Usuario ID:', req.session?.usuarioID);
    
    // Guardar la sesiÃ³n en cada request para mantenerla activa
    if (req.session?.usuarioID) {
        req.session.touch();
        req.session.save((err) => {
            if (err) console.error('Error al guardar sesiÃ³n:', err);
            next();
        });
    } else {
        next();
    }
});

// Rutas estÃ¡ticas - no necesitan sesiÃ³n
const staticOptions = {
    etag: true,
    lastModified: true,
    setHeaders: (res, path) => {
        res.setHeader('Cache-Control', 'public, max-age=3600');
    }
};

app.use("/css", express.static(__dirname + "/views/css", staticOptions));
app.use("/imagenes", express.static(__dirname + "/views/imagenes", staticOptions));
app.use(express.static(path.join(__dirname, 'views'), staticOptions));

// Middleware para verificar sesiÃ³n en rutas protegidas
const verificarSesion = (req, res, next) => {
    if (!req.session?.usuarioID) {
        console.log('âŒ Acceso denegado: no hay sesiÃ³n');
        return res.redirect('/login');
    }
    console.log('âœ… SesiÃ³n verificada para usuario:', req.session.usuarioID);
    next();
};

// Rutas protegidas que requieren sesiÃ³n
app.get("/cursos", verificarSesion, (req, res) => {
    console.log('ðŸŽ“ Mostrando cursos para usuario:', req.session.usuarioID);
    
    // Obtener todos los cursos de la base de datos
    const sql = `
        SELECT ID_CURSO, NOMBRE_CURSO, DESCRIPCION, PRECIO, URL_VIDEO
        FROM curso
        ORDER BY ID_CURSO DESC
    `;
    
    conexion.query(sql, (err, cursos) => {
        if (err) {
            console.error('Error al obtener cursos:', err);
            return res.status(500).send('Error al cargar los cursos');
        }
        
        res.render("cursos", { 
            usuarioID: req.session.usuarioID,
            usuario: req.session.usuario,
            cursos: cursos
        });
    });
});
app.get("/login", (req, res) => {
  // Si ya hay sesiÃ³n, redirigir segÃºn el rol
  if (req.session?.usuarioID) {
    console.log('ðŸ‘¤ Usuario ya logueado, redirigiendo segÃºn rol');
    return res.redirect(req.session.rol === "admin" ? "/admin" : "/index1");
  }
  console.log('ðŸ“ Mostrando pÃ¡gina de login');
  res.render("login");
});
app.get("/registro", (req, res) => {
  res.render("registro");
});
app.get("/carrito", (req, res) => {
  if (!req.session.usuarioID || req.session.rol !== "usuario") return res.redirect("/login");
  res.render("carrito", { usuarioID: req.session.usuarioID });
});

app.get("/perfil", (req, res) => {
  if (!req.session.usuarioID || req.session.rol !== "usuario") return res.redirect("/login");
  res.render("perfil", { usuarioID: req.session.usuarioID });
});

// Ruta para mostrar el formulario de editar cuenta
app.get("/editar-cuenta", verificarSesion, (req, res) => {
  // Obtener email actual del usuario
  const sql = "SELECT p.EMAIL FROM persona p JOIN usuario u ON p.DNI = u.DNI WHERE u.ID_USUARIO = ?";
  conexion.query(sql, [req.session.usuarioID], (err, results) => {
    if (err) {
      console.error('Error al obtener datos del usuario:', err);
      return res.render("editar-cuenta", { error: "Error al cargar los datos" });
    }
    const email = results[0]?.EMAIL || '';
    res.render("editar-cuenta", { email: email });
  });
});

// Ruta para actualizar el email
app.post("/actualizar-email", verificarSesion, async (req, res) => {
  const { "email-nuevo": nuevoEmail } = req.body;
  if (!nuevoEmail) {
    return res.render("editar-cuenta", { error: "El email es requerido" });
  }

  try {
    // Actualizar email en la tabla persona
    const sql = "UPDATE persona p JOIN usuario u ON p.DNI = u.DNI SET p.EMAIL = ? WHERE u.ID_USUARIO = ?";
    conexion.query(sql, [nuevoEmail, req.session.usuarioID], (err) => {
      if (err) {
        console.error('Error al actualizar email:', err);
        return res.render("editar-cuenta", { error: "Error al actualizar el email" });
      }
      res.render("editar-cuenta", { success: "Email actualizado correctamente", email: nuevoEmail });
    });
  } catch (error) {
    console.error('Error:', error);
    res.render("editar-cuenta", { error: "Error interno del servidor" });
  }
});

// Ruta para actualizar la contraseÃ±a
app.post("/actualizar-password", verificarSesion, async (req, res) => {
  const { "pass-actual": passActual, "pass-nuevo": passNuevo } = req.body;
  if (!passActual || !passNuevo) {
    return res.render("editar-cuenta", { error: "Ambas contraseÃ±as son requeridas" });
  }

  try {
    // Verificar contraseÃ±a actual
    const sqlVerificar = "SELECT CONTRASENIA FROM usuario WHERE ID_USUARIO = ?";
    conexion.query(sqlVerificar, [req.session.usuarioID], async (err, results) => {
      if (err) {
        console.error('Error al verificar contraseÃ±a:', err);
        return res.render("editar-cuenta", { error: "Error al verificar la contraseÃ±a" });
      }

      const usuario = results[0];
      const esValida = await bcrypt.compare(passActual, usuario.CONTRASENIA);
      if (!esValida) {
        return res.render("editar-cuenta", { error: "La contraseÃ±a actual es incorrecta" });
      }

      // Hash de la nueva contraseÃ±a
      const hash = await bcrypt.hash(passNuevo, 10);

      // Actualizar contraseÃ±a
      const sqlUpdate = "UPDATE usuario SET CONTRASENIA = ? WHERE ID_USUARIO = ?";
      conexion.query(sqlUpdate, [hash, req.session.usuarioID], (err) => {
        if (err) {
          console.error('Error al actualizar contraseÃ±a:', err);
          return res.render("editar-cuenta", { error: "Error al actualizar la contraseÃ±a" });
        }
        res.render("editar-cuenta", { success: "ContraseÃ±a actualizada correctamente" });
      });
    });
  } catch (error) {
    console.error('Error:', error);
    res.render("editar-cuenta", { error: "Error interno del servidor" });
  }
});

app.get("/sobremi", (req, res) => {
    res.render("sobremi", { usuario: req.session.usuario });
});

app.get("/contacto", (req, res) => {
    res.render("contacto");
});

app.get("/servicios", (req, res) => {
    res.render("servicios", { usuario: req.session.usuario });
});

// ----------------- Rutas -----------------
app.get("/", (req, res) => {
    // Si hay sesiÃ³n, redirigir segÃºn el rol
    if (req.session?.usuarioID) {
        console.log('ðŸ‘¤ Usuario logueado, redirigiendo segÃºn rol');
        return res.redirect(req.session.rol === "admin" ? "/admin" : "/index1");
    }
    console.log('ðŸ“ Redirigiendo a login');
    res.redirect('/login');
});

app.get("/index1", (req, res) => {
    // Verificar si hay sesiÃ³n
    if (!req.session?.usuarioID) {
        console.log('âŒ No hay sesiÃ³n, redirigiendo a login');
        return res.redirect('/login');
    }
    console.log('âœ… Mostrando index1 para usuario:', req.session.usuarioID);
    res.render("index1", { usuario: req.session.usuario });
});

// ----------------- Login y registro -----------------
// ----------------- Login y Registro (con bcrypt) -----------------

// Iniciar sesiÃ³n
app.post("/iniciar", async (req, res) => {
    console.log('ðŸ”‘ Intento de inicio de sesiÃ³n');
    const { usuarioIng, contrasenaIng } = req.body;

    try {
        if (!usuarioIng || !contrasenaIng) {
            console.log('âŒ Faltan datos de inicio de sesiÃ³n');
            return res.status(400).send("Falta usuario o contraseÃ±a");
        }

        const consultaUsuario = "SELECT * FROM usuario WHERE NOMBRE = ?";
        conexion.query(consultaUsuario, [usuarioIng], async (error, resultadoUsuario) => {
            if (error) {
                console.error("âŒ Error en consulta:", error);
                return res.status(500).send("Error del servidor");
            }

            if (resultadoUsuario.length === 0) {
                console.log('âŒ Usuario no encontrado:', usuarioIng);
                return res.status(401).send("Usuario no encontrado");
            }

            const usuario = resultadoUsuario[0];
            const esValida = await bcrypt.compare(contrasenaIng, usuario.CONTRASENIA);

            if (!esValida) {
                console.log('âŒ ContraseÃ±a incorrecta para usuario:', usuarioIng);
                return res.status(401).send("ContraseÃ±a incorrecta");
            }

            // Verificar si es administrador
            const esAdmin = await new Promise((resolve) => {
                conexion.query('SELECT 1 FROM ADMINISTRADOR WHERE ID_USUARIO = ?', 
                    [usuario.ID_USUARIO],
                    (err, results) => {
                        if (err) {
                            console.error('Error al verificar administrador:', err);
                            resolve(false);
                        }
                        resolve(results && results.length > 0);
                    }
                );
            });

            // Establecer la sesiÃ³n
            req.session.usuarioID = usuario.ID_USUARIO;
            req.session.rol = esAdmin ? "admin" : "usuario";
            req.session.usuario = usuario.NOMBRE;
            
            // Forzar guardado de sesiÃ³n
            await new Promise((resolve, reject) => {
                req.session.save((err) => {
                    if (err) {
                        console.error("âŒ Error al guardar sesiÃ³n:", err);
                        reject(err);
                    } else {
                        resolve();
                    }
                });
            });
            
            console.log("âœ… SesiÃ³n iniciada para usuario:", {
                id: req.sessionID,
                usuarioID: usuario.ID_USUARIO,
                nombre: usuario.NOMBRE,
                cookie: req.session.cookie
            });
            
            // Enviar las cookies antes de redirigir
            res.setHeader('Cache-Control', 'no-store');
            res.setHeader('Pragma', 'no-cache');
            
            // Redirigir segÃºn el rol
            return res.redirect(req.session.rol === "admin" ? "/admin" : "/index1");
        });
    } catch (err) {
        console.error("âŒ Error general:", err);
        res.status(500).send("Error del servidor");
    }
});

// Registrar nuevo usuario
app.post("/registrar", async (req, res) => {
  const { nombre, apellido, DNI, correo, telefono, contrasena } = req.body;

  if (!nombre || !apellido || !DNI || !correo || !telefono || !contrasena) {
    return res.status(400).send("Faltan datos en el registro");
  }

  try {
    // Verificar si el usuario o DNI ya existen
    const verificarUsuario = "SELECT * FROM usuario WHERE DNI = ? OR NOMBRE = ?";
    conexion.query(verificarUsuario, [DNI, correo], async (error, resultado) => {
      if (error) {
        console.error("âŒ Error al verificar usuario:", error);
        return res.status(500).send("Error al verificar usuario");
      }

      if (resultado.length > 0) {
        return res.status(409).send("El usuario o DNI ya estÃ¡n registrados");
      }

      // Generar hash seguro con bcrypt
      const hash = await bcrypt.hash(contrasena, 10);

      // Insertar en tabla persona
      const registrarPersona = `
        INSERT INTO persona (DNI, NOMBRE, APELLIDO, EMAIL, TELEFONO)
        VALUES (?, ?, ?, ?, ?)
      `;
      conexion.query(registrarPersona, [DNI, nombre, apellido, correo, telefono], (errorPersona) => {
        if (errorPersona) {
          console.error("âŒ Error al registrar persona:", errorPersona);
          return res.status(500).send("Error al registrar persona");
        }

        // Insertar en tabla usuario con contraseÃ±a hasheada
        const registrarUsuario = `
          INSERT INTO usuario (DNI, NOMBRE, CONTRASENIA)
          VALUES (?, ?, ?)
        `;
        conexion.query(registrarUsuario, [DNI, correo, hash], async (errorUsuario) => {
          if (errorUsuario) {
            console.error("âŒ Error al registrar usuario:", errorUsuario);
            return res.status(500).send(errorUsuario.message || "Error al registrar usuario");
          }

          // Obtener el ID del usuario reciÃ©n creado
          const [nuevoUsuario] = await new Promise((resolve, reject) => {
            conexion.query('SELECT ID_USUARIO FROM usuario WHERE DNI = ?', [DNI], (err, results) => {
              if (err) return reject(err);
              resolve(results);
            });
          });

          console.log(`âœ… Usuario ${correo} registrado correctamente`);
          return res.send("Usuario registrado con Ã©xito. Presiona F5 para volver."); 
        });
      });
    });
  } catch (err) {
    console.error("âŒ Error general en registro:", err);
    res.status(500).send("Error interno del servidor");
  }
});

app.get("/logout", (req, res) => {
  req.session.destroy(err => {
    if (err) return res.status(500).send("Error al cerrar sesiÃ³n");
    res.redirect("/login");
  });
});

// Ruta de desarrollo: setea sesiÃ³n para pruebas rÃ¡pidas (SOLO en desarrollo)
if ((process.env.NODE_ENV || 'development') !== 'production') {
  app.get('/dev-login', (req, res) => {
    const id = Number(req.query.id || 5);
    req.session.usuarioID = id;
    req.session.usuario = { nombre: 'Dev User ' + id };
    req.session.save(err => {
      if (err) {
        console.error('Error al guardar sesiÃ³n en /dev-login:', err);
        return res.status(500).json({ ok: false, error: 'session-save-failed' });
      }
      console.log('ðŸ”§ /dev-login: sesiÃ³n creada para usuario', id);
      return res.json({ ok: true, usuarioID: id });
    });
  });

  // Ruta para mostrar dashboard (usa verificarSesion para asegurar login)
  app.get('/dashboard', verificarSesion, (req, res) => {
    try {
      // Pasar nombre de usuario a la plantilla y obtener cursos comprados
      const usuario = req.session?.usuario || req.session?.usuario?.nombre || req.session?.usuarioID;

      const sql = `
        SELECT c.ID_CARRITO, c.ID_CURSO, cr.NOMBRE_CURSO, cr.PRECIO, c.FECHACOMPRA,
               DATE_ADD(c.FECHACOMPRA, INTERVAL 30 DAY) AS expiresOn,
               DATEDIFF(DATE_ADD(c.FECHACOMPRA, INTERVAL 30 DAY), CURDATE()) AS diasRestantes
        FROM CARRITO c
        JOIN COMPROBANTE comp ON comp.ID_CARRITO = c.ID_CARRITO
        LEFT JOIN CURSO cr ON c.ID_CURSO = cr.ID_CURSO
        WHERE c.ID_USUARIO = ?
        ORDER BY c.FECHACOMPRA DESC
      `;

      conexion.query(sql, [req.session.usuarioID], (err, results) => {
        if (err) {
          console.error('âŒ Error cargando cursos en dashboard:', err);
          // Renderizar dashboard vacÃ­o pero informar
          return res.render('dashboard', { usuario, courses: [] });
        }

        const courses = (results || []).map(r => ({
          id: r.ID_CURSO,
          carritoId: r.ID_CARRITO,
          title: r.NOMBRE_CURSO || `Curso ${r.ID_CURSO}`,
          price: r.PRECIO,
          purchasedOn: r.FECHACOMPRA,
          expiresOn: r.expiresOn,
          diasRestantes: Number(r.diasRestantes) >= 0 ? Number(r.diasRestantes) : 0
        }));

        return res.render('dashboard', { usuario, courses });
      });
    } catch (err) {
      console.error('âŒ Error renderizando /dashboard:', err);
      return res.status(500).send('Error mostrando dashboard');
    }
  });
}

// ----------------- ConfiguraciÃ³n Mercado Pago-----------------
app.get("/configMercadoPago", (req, res) => {
  try {
  // no need to configure here; just return the public key
  res.json({ publicKey: process.env.MP_PUBLIC_KEY });
  } catch (error) {
    console.error("Error en configuraciÃ³n MP:", error);
    res.status(500).send("Error en configuraciÃ³n de MercadoPago");
  }
});

// Endpoint para generar preferencia de pago
// Middleware para verificar los datos necesarios para el pago
const verificarDatosPago = (req, res, next) => {
    if (!process.env.MP_ACCESS_TOKEN || !process.env.MP_PUBLIC_KEY) {
        console.error('âŒ Error: Faltan credenciales de MercadoPago');
        return res.status(500).send('Error de configuraciÃ³n del servidor');
    }
    if (!process.env.BASE_URL) {
        console.error('âŒ Error: Falta BASE_URL');
        return res.status(500).send('Error de configuraciÃ³n del servidor');
    }
    next();
};

app.get('/generar', verificarDatosPago, async (req, res) => {
    try {
        // VerificaciÃ³n estricta de sesiÃ³n
        const usuarioID = req.session?.usuarioID;
    console.log('ðŸ” Verificando sesiÃ³n en /generar:', {
      sessionID: req.sessionID,
      usuarioID: usuarioID,
      sessionContent: req.session,
      origin: req.headers.origin,
      isAjaxRequest: (req.query.json === '1' || (req.headers.accept || '').includes('application/json'))
    });

    if (!usuarioID) {
      console.log('âŒ Usuario no autenticado en /generar');
      // Si la peticiÃ³n viene desde AJAX/mobile devolver JSON para que el cliente pueda manejarlo
      if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
        return res.status(401).json({ error: 'no-auth', message: 'Usuario no autenticado' });
      }
      return res.redirect('/login');
    }

        const cursoId = req.query.cursoId;
        console.log('ðŸ“¦ Buscando curso:', cursoId);

        let curso = null;

        // Si no se proporciona cursoId, usar curso de prueba
        if (!cursoId) {
            console.log('â„¹ï¸ No se proporcionÃ³ cursoId, usando curso de prueba');
            curso = {
                ID_CURSO: 0,
                NOMBRE_CURSO: 'Curso de prueba',
                PRECIO: 100
            };
        } else {
            try {
                curso = await new Promise((resolve, reject) => {
                    conexion.query(
                        'SELECT ID_CURSO, NOMBRE_CURSO, PRECIO FROM CURSO WHERE ID_CURSO = ?',
                        [cursoId],
                        (err, results) => {
                            if (err) {
                                console.error('âŒ Error en consulta SQL:', err);
                                return reject(err);
                            }
                            if (!results || results.length === 0) {
                                console.log('âš ï¸ No se encontrÃ³ el curso:', cursoId);
                                return resolve(null);
                            }
                            console.log('âœ… Curso encontrado:', results[0]);
                            return resolve(results[0]);
                        }
                    );
                });
            } catch (dbError) {
                console.error('âŒ Error al consultar la base de datos:', dbError);
                return res.status(500).send('Error al buscar el curso');
            }
        }

        // Si no se encontrÃ³ el curso, usar uno de prueba
        if (!curso) {
            console.log('â„¹ï¸ Usando curso de prueba por fallback');
            curso = {
                ID_CURSO: cursoId || 0,
                NOMBRE_CURSO: 'Curso de prueba',
                PRECIO: 100
            };
        }

    // Comprobar si el usuario ya pagÃ³ este curso (evitar pago duplicado)
    try {
      const existePago = await new Promise((resolve, reject) => {
        const sql = `SELECT comp.NUM_OP FROM COMPROBANTE comp JOIN CARRITO c ON comp.ID_CARRITO = c.ID_CARRITO WHERE c.ID_USUARIO = ? AND c.ID_CURSO = ? LIMIT 1`;
        conexion.query(sql, [usuarioID, curso.ID_CURSO], (err, results) => {
          if (err) return reject(err);
          if (!results || results.length === 0) return resolve(null);
          return resolve(results[0]);
        });
      });

      if (existePago) {
        console.log(`âš ï¸ Usuario ${usuarioID} ya pagÃ³ el curso ${curso.ID_CURSO} (op=${existePago.NUM_OP})`);
        if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
          return res.status(409).json({ error: 'already_paid', message: 'Ya pagaste este curso', num_op: existePago.NUM_OP });
        }
        // Para peticiones normales, redirigir a la lista de cursos
        return res.redirect('/cursos');
      }
    } catch (dbCheckErr) {
      console.error('âŒ Error comprobando pagos existentes:', dbCheckErr);
      // No impedir la compra por error en la comprobaciÃ³n; pero loguearlo
    }

    // Si se configurÃ³ un payment link estÃ¡tico (p.ej. link de Mercado Pago), usarlo
    if (process.env.MP_PAYMENT_LINK) {
      const raw = process.env.MP_PAYMENT_LINK;
      const payUrl = raw.startsWith('http') ? raw : `https://${raw}`;
      console.log('â„¹ï¸ Usando MP_PAYMENT_LINK configurado ->', payUrl);
      if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
        return res.json({ init_point: payUrl, id: null });
      }
      return res.redirect(payUrl);
    }

    // Crear cliente y preferencia
        console.log('ðŸ”‘ Usando token:', process.env.MP_ACCESS_TOKEN?.substring(0, 10) + '...');
        
        const client = new MercadoPagoConfig({ 
            accessToken: process.env.MP_ACCESS_TOKEN 
        });

        // Asegurarnos de que el precio sea un nÃºmero
        const precio = Number(curso.PRECIO) || 100;
        console.log('ðŸ’µ Precio del curso:', precio);

        const preference = {
            items: [{
                id: curso.ID_CURSO.toString(),
                title: curso.NOMBRE_CURSO || 'Curso',
                quantity: 1,
                unit_price: precio,
                currency_id: 'ARS',
                description: 'Compra de curso en plataforma'
            }],
            payer: {
                email: 'test_user@example.com',
                name: 'Test User',
                identification: {
                    type: 'DNI',
                    number: '12345678'
                }
            },
            payment_methods: {
                excluded_payment_types: [
                    { id: "ticket" }
                ],
                installments: 1
            },
      // Incluir metadata con el ID de vendedor para que llegue en la notificaciÃ³n
      metadata: {
        seller_id: process.env.MP_MERCHANT_ID || 'unknown'
      },
      back_urls: {
        success: `${BASE_URL}/success`,
        failure: `${BASE_URL}/failure`,
        pending: `${BASE_URL}/pending`
      },
            external_reference: `${usuarioID}-${curso.ID_CURSO}`,
      notification_url: `${BASE_URL}/notificar?usuario=${usuarioID}&curso=${curso.ID_CURSO}`
        };

        console.log('ðŸ’° Generando preferencia:', JSON.stringify(preference, null, 2));

    try {
      const response = await new Preference(client).create({ body: preference });
      console.log('âœ¨ Preferencia creada:', response.id);

      if (!response.init_point) {
        console.error('âŒ La respuesta de MP no incluyÃ³ init_point:', response);
        // Si el cliente esperaba JSON, devolver error JSON
        if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
          return res.status(500).json({ error: 'No se pudo obtener URL de pago desde Mercado Pago' });
        }
        return res.redirect('/failure');
      }

      console.log('ðŸ”— URL de pago:', response.init_point);

      // Soporte para cliente AJAX/mÃ³vil: si se solicita JSON, devolver init_point
      if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
        return res.json({ init_point: response.init_point, id: response.id });
      }
      return res.redirect(response.init_point);
    } catch (mpError) {
      console.error('âŒ Error al crear preferencia:', mpError);
      console.error('Detalles:', mpError.response?.data || mpError.message);
      // Si el request viene desde AJAX/mobile devolver el error en JSON
      if (req.query.json === '1' || (req.headers.accept || '').includes('application/json')) {
        return res.status(500).json({ error: mpError.response?.data || mpError.message });
      }
      // En caso de peticiÃ³n normal redirigir a pÃ¡gina de fallo amigable
      return res.redirect('/failure');
    }

    } catch (error) {
        console.error('âŒ Error:', error);
        res.status(500).send('Error al generar preferencia');
    }
});

// Endpoint para verificar si el usuario tiene acceso vigente a un curso (30 dÃ­as)
app.get('/verificar-acceso', async (req, res) => {
  try {
    const usuarioID = req.session?.usuarioID;
    const cursoId = Number(req.query.cursoId || req.query.id);
    if (!usuarioID) return res.status(401).json({ access: false, message: 'no-auth' });
    if (!cursoId) return res.status(400).json({ access: false, message: 'cursoId requerido' });

    // Buscar la compra mÃ¡s reciente para ese usuario/curso
    const sql = `
      SELECT c.FECHACOMPRA,
             DATE_ADD(c.FECHACOMPRA, INTERVAL 30 DAY) AS vencimiento,
             DATEDIFF(DATE_ADD(c.FECHACOMPRA, INTERVAL 30 DAY), CURDATE()) AS dias_restantes
      FROM CARRITO c
      JOIN COMPROBANTE comp ON comp.ID_CARRITO = c.ID_CARRITO
      WHERE c.ID_USUARIO = ? AND c.ID_CURSO = ?
      ORDER BY c.FECHACOMPRA DESC
      LIMIT 1
    `;

    conexion.query(sql, [usuarioID, cursoId], (err, results) => {
      if (err) {
        console.error('âŒ Error consultando acceso a curso:', err);
        return res.status(500).json({ access: false, message: 'db-error' });
      }

      if (!results || results.length === 0) {
        return res.json({ access: false, diasRestantes: 0 });
      }

      const row = results[0];
      const diasRestantes = Number(row.dias_restantes);
      const access = diasRestantes >= 0;
      return res.json({
        access: access,
        diasRestantes: access ? diasRestantes : 0,
        purchasedOn: row.FECHACOMPRA,
        expiresOn: row.vencimiento
      });
    });
  } catch (error) {
    console.error('âŒ Error en /verificar-acceso:', error);
    return res.status(500).json({ access: false, message: 'internal-error' });
  }
});

// Middleware: verificar que el usuario tenga acceso vigente al curso (30 dÃ­as)
const verificarAccesoCurso = (req, res, next) => {
  try {
    const usuarioID = req.session?.usuarioID;
    const cursoId = Number(req.params.id || req.query.cursoId || req.body.cursoId);
    if (!usuarioID) return res.status(401).json({ access: false, message: 'no-auth' });
    if (!cursoId) return res.status(400).json({ access: false, message: 'cursoId requerido' });

    const sql = `
      SELECT c.FECHACOMPRA,
             DATE_ADD(c.FECHACOMPRA, INTERVAL 30 DAY) AS vencimiento,
             DATEDIFF(DATE_ADD(c.FECHACOMPRA, INTERVAL 30 DAY), CURDATE()) AS dias_restantes
      FROM CARRITO c
      JOIN COMPROBANTE comp ON comp.ID_CARRITO = c.ID_CARRITO
      WHERE c.ID_USUARIO = ? AND c.ID_CURSO = ?
      ORDER BY c.FECHACOMPRA DESC
      LIMIT 1
    `;

    conexion.query(sql, [usuarioID, cursoId], (err, results) => {
      if (err) {
        console.error('âŒ Error verificando acceso a curso (middleware):', err);
        return res.status(500).json({ access: false, message: 'db-error' });
      }

      if (!results || results.length === 0) {
        // No existe compra
        return res.status(403).json({ access: false, message: 'no-purchase' });
      }

      const row = results[0];
      const diasRestantes = Number(row.dias_restantes);
      const access = diasRestantes >= 0;
      if (!access) {
        return res.status(403).json({ access: false, diasRestantes: 0, purchasedOn: row.FECHACOMPRA, expiresOn: row.vencimiento });
      }

      // Adjuntar info Ãºtil a la request para handlers posteriores
      req.courseAccess = { access: true, diasRestantes: diasRestantes, purchasedOn: row.FECHACOMPRA, expiresOn: row.vencimiento };
      return next();
    });
  } catch (error) {
    console.error('âŒ Error en verificarAccesoCurso middleware:', error);
    return res.status(500).json({ access: false, message: 'internal-error' });
  }
};

// Ruta de ejemplo protegida por el middleware: devuelve el contenido del curso si estÃ¡ dentro de los 30 dÃ­as
app.get('/curso/:id/contenido', verificarSesion, verificarAccesoCurso, (req, res) => {
  try {
    const cursoId = Number(req.params.id);
    console.log(`â–¶ï¸ Usuario ${req.session?.usuarioID} accediendo al contenido del curso ${cursoId}`);

    // Obtener informaciÃ³n del curso y su contenido
    const sql = `
      SELECT 
        c.ID_CURSO,
        c.NOMBRE_CURSO,
        c.DESCRIPCION,
        c.URL_VIDEO,
        car.FECHACOMPRA,
        DATE_ADD(car.FECHACOMPRA, INTERVAL 30 DAY) AS fechaExpiracion,
        DATEDIFF(DATE_ADD(car.FECHACOMPRA, INTERVAL 30 DAY), CURDATE()) AS diasRestantes
      FROM CURSO c
      JOIN CARRITO car ON car.ID_CURSO = c.ID_CURSO
      JOIN COMPROBANTE comp ON comp.ID_CARRITO = car.ID_CARRITO
      WHERE c.ID_CURSO = ? AND car.ID_USUARIO = ?
      ORDER BY car.FECHACOMPRA DESC
      LIMIT 1
    `;

    conexion.query(sql, [cursoId, req.session.usuarioID], (err, results) => {
      if (err) {
        console.error('âŒ Error obteniendo datos del curso:', err);
        return res.status(500).send('Error al cargar el contenido del curso');
      }

      if (!results || results.length === 0) {
        return res.status(404).send('Curso no encontrado');
      }

      const curso = {
        id: results[0].ID_CURSO,
        titulo: results[0].NOMBRE_CURSO,
        descripcion: results[0].DESCRIPCION,
        videoUrl: results[0].URL_VIDEO,
        fechaCompra: results[0].FECHACOMPRA,
        fechaExpiracion: results[0].fechaExpiracion,
        diasRestantes: results[0].diasRestantes
      };

      return res.render('curso-contenido', { 
        curso, 
        diasRestantes: curso.diasRestantes,
        usuarioID: req.session.usuarioID 
      });
    });
  } catch (err) {
    console.error('âŒ Error sirviendo contenido del curso:', err);
    return res.status(500).send('Error interno al intentar acceder al contenido');
  }
});

app.get('/success', (req, res) => {
  res.send("Pago realizado con Ã©xito");
});

// PÃ¡gina amigable de fallo de pago para evitar el error genÃ©rico de Mercado Pago
app.get('/failure', (req, res) => {
  try {
    return res.render('failure');
  } catch (err) {
    console.error('Error al renderizar /failure:', err);
    return res.status(500).send('Error mostrando la pÃ¡gina de fallo');
  }
});

// Ruta de diagnÃ³stico para verificar el estado del checkout
app.get('/checkout-status', (req, res) => {
  const status = {
    session: {
      active: !!req.session,
      id: req.sessionID,
      usuarioID: req.session?.usuarioID
    },
    headers: {
      origin: req.headers.origin,
      host: req.headers.host,
      cookie: !!req.headers.cookie
    },
    env: {
      baseUrl: !!process.env.BASE_URL,
      mpToken: !!process.env.MP_ACCESS_TOKEN,
      mpPublic: !!process.env.MP_PUBLIC_KEY
    }
  };
  console.log('ðŸ“Š Estado del checkout:', status);
  res.json(status);
});

// Endpoint de diagnÃ³stico para comprobar CORS, cookies y reachability desde el cliente
app.get('/ping', (req, res) => {
  console.log('ðŸ“ /ping recibido desde origin=', req.headers.origin, ' cookies=', req.headers.cookie);
  res.json({ ok: true, origin: req.headers.origin || null, cookies: req.headers.cookie || null, session: { usuarioID: req.session?.usuarioID, rol: req.session?.rol } });
});

app.all('/notificar', async (req, res) => {
  try {
    const query = req.query || {};
    const topic = (query.topic || query.type || '').toString();
    const usuario = query.usuario || query.user || null;
    const curso = query.curso || query.course || null;

    const client = new MercadoPagoConfig({ accessToken: process.env.MP_ACCESS_TOKEN });

    // Helper: evita inserciones duplicadas comprobando COMPROBANTE por NUM_OP
    const comprobanteExiste = async (numOp) => {
      return new Promise((resolve, reject) => {
        conexion.query('SELECT 1 FROM COMPROBANTE WHERE NUM_OP = ? LIMIT 1', [numOp], (err, results) => {
          if (err) return reject(err);
          resolve(Array.isArray(results) && results.length > 0);
        });
      });
    };

    const crearCompra = async (usuarioId, cursoId, numOp) => {
      // Crear carrito
      const carritoId = await new Promise((resolve, reject) => {
        conexion.query(
          'INSERT INTO CARRITO (ID_USUARIO, ID_CURSO, CANTIDAD, FECHACOMPRA) VALUES (?, ?, 1, CURDATE())',
          [usuarioId, cursoId],
          (error, results) => {
            if (error) return reject(error);
            resolve(results.insertId);
          }
        );
      });

      // Crear comprobante
      await new Promise((resolve, reject) => {
        conexion.query(
          'INSERT INTO COMPROBANTE (ID_CARRITO, ID_USUARIO, NUM_OP) VALUES (?, ?, ?)',
          [carritoId, usuarioId, numOp],
          (error) => {
            if (error) return reject(error);
            resolve();
          }
        );
      });
      console.log(`âœ… Compra registrada: usuario=${usuarioId}, curso=${cursoId}, op=${numOp}`);
    };

    // Process payment notifications
    if (topic.includes('payment')) {
      const paymentId = query.id || query['data.id'] || (req.body && (req.body.id || req.body['data.id']));
      if (!paymentId) {
        console.warn('âš ï¸ notificar: payment topic sin id');
        return res.sendStatus(200);
      }

      let paymentInfo;
      try {
        // Usar axios directo a la API de Mercado Pago como fallback
        const resp = await axios.get(`https://api.mercadopago.com/v1/payments/${paymentId}`, {
          headers: { Authorization: `Bearer ${process.env.MP_ACCESS_TOKEN}` }
        });
        paymentInfo = resp.data;
      } catch (err) {
        console.error('âŒ Error consultando pago en MP:', err && err.message ? err.message : err);
        return res.sendStatus(200);
      }

      const status = paymentInfo?.status || paymentInfo?.status_detail;
      console.log('ðŸ“£ notificar payment status =', status);

      if (status === 'approved' || status === 'authorized') {
        if (!usuario || !curso) {
          console.warn('âš ï¸ notificar: faltan usuario o curso en query, no se crea registro');
          return res.sendStatus(200);
        }

        const exists = await comprobanteExiste(paymentId);
        if (exists) {
          console.log('â„¹ï¸ Comprobante ya existe para NUM_OP', paymentId);
          return res.sendStatus(200);
        }

        await crearCompra(usuario, curso, paymentId);
      }

      return res.sendStatus(200);
    }

    // Process merchant_order (puede contener varios pagos)
    if (topic.includes('merchant_order') || topic.includes('merchant')) {
      const orderId = query.id || query['id'] || (req.body && (req.body.id || req.body['data.id']));
      if (!orderId) {
        console.warn('âš ï¸ notificar: merchant_order sin id');
        return res.sendStatus(200);
      }

      let orderInfo;
      try {
        const resp = await axios.get(`https://api.mercadopago.com/merchant_orders/${orderId}`, {
          headers: { Authorization: `Bearer ${process.env.MP_ACCESS_TOKEN}` }
        });
        orderInfo = resp.data;
      } catch (err) {
        console.error('âŒ Error consultando merchant_order en MP:', err && err.message ? err.message : err);
        return res.sendStatus(200);
      }

      const payments = orderInfo?.payments || [];
      for (const p of payments) {
        const pid = p.id || p.payment_id;
        const pst = p.status || p.status_detail || p.status;
        if (pid && (pst === 'approved' || pst === 'authorized')) {
          if (!usuario || !curso) {
            console.warn('âš ï¸ notificar(merchant): faltan usuario o curso en query, no se crea registro');
            continue;
          }
          const exists = await comprobanteExiste(pid);
          if (exists) {
            console.log('â„¹ï¸ Comprobante ya existe para NUM_OP', pid);
            continue;
          }
          await crearCompra(usuario, curso, pid);
        }
      }

      return res.sendStatus(200);
    }

    // Para otros topics, simplemente ACK
    return res.sendStatus(200);
  } catch (error) {
    console.error('âŒ Error en notificaciÃ³n general:', error);
    return res.status(500).send('Error al procesar notificaciÃ³n');
  }
});

// ----------------- Rutas de Administrador -----------------
// Middleware para verificar si es administrador
const verificarAdmin = (req, res, next) => {
  if (!req.session?.usuarioID) {
    console.log('âŒ Acceso denegado: no hay sesiÃ³n');
    return res.redirect('/login');
  }

  // Comprobar si es admin consultando la tabla ADMINISTRADOR
  conexion.query('SELECT 1 FROM ADMINISTRADOR WHERE ID_USUARIO = ? LIMIT 1', [req.session.usuarioID], (err, results) => {
    if (err) {
      console.error('Error verificando administrador:', err);
      return res.redirect('/login');
    }

    if (!results || results.length === 0) {
      console.log('âŒ Acceso denegado: no es administrador');
      return res.redirect('/login');
    }

    console.log('âœ… Acceso de administrador verificado');
    next();
  });
};

// Ruta de aterrizaje para administradores (mostrada al iniciar sesiÃ³n)
app.get('/admin', verificarAdmin, (req, res) => {
  // Vista simple con dos cuadrados: ir a la pÃ¡gina pÃºblica o al panel de admin
  res.render('admin-landing', { admin: req.session.usuario });
});

// Ruta real del panel de administraciÃ³n con la lÃ³gica previa
app.get('/admin/panel', verificarAdmin, async (req, res) => {
  try {
    // Obtener estadÃ­sticas
    const stats = await new Promise((resolve, reject) => {
      conexion.query(`
        SELECT 
          (SELECT COUNT(*) FROM usuario) as totalUsuarios,
          (SELECT COUNT(*) FROM curso) as totalCursos,
          (SELECT COALESCE(SUM(cr.PRECIO), 0) FROM carrito c 
           JOIN curso cr ON c.ID_CURSO = cr.ID_CURSO 
           JOIN comprobante cp ON c.ID_CARRITO = cp.ID_CARRITO) as ventasTotales,
          (SELECT COALESCE(SUM(cr.PRECIO), 0) FROM carrito c 
           JOIN curso cr ON c.ID_CURSO = cr.ID_CURSO 
           JOIN comprobante cp ON c.ID_CARRITO = cp.ID_CARRITO 
           WHERE MONTH(c.FECHACOMPRA) = MONTH(CURRENT_DATE())) as ventasMes
      `, (err, results) => {
        if (err) return reject(err);
        resolve(results[0]);
      });
    });

    // Obtener usuarios
    const usuarios = await new Promise((resolve, reject) => {
      conexion.query(`
        SELECT u.ID_USUARIO as id, u.NOMBRE as nombre, p.EMAIL as email, 
             CASE WHEN EXISTS (SELECT 1 FROM ADMINISTRADOR a WHERE a.ID_USUARIO = u.ID_USUARIO)
              THEN 'Administrador' ELSE 'Usuario' END as rol
        FROM usuario u
        JOIN persona p ON u.DNI = p.DNI
        ORDER BY u.ID_USUARIO DESC
      `, (err, results) => {
        if (err) return reject(err);
        resolve(results);
      });
    });

    // Obtener cursos (incluye URL_VIDEO)
    const cursos = await new Promise((resolve, reject) => {
      conexion.query(`
        SELECT 
          ID_CURSO as id, 
          NOMBRE_CURSO as nombre, 
          PRECIO as precio,
          DESCRIPCION as descripcion,
          URL_VIDEO as urlVideo
        FROM curso
        ORDER BY ID_CURSO DESC
      `, (err, results) => {
        if (err) return reject(err);
        resolve(results);
      });
    });

    // Obtener ventas
    const ventas = await new Promise((resolve, reject) => {
      conexion.query(`
        SELECT c.ID_CARRITO as id, 
             u.NOMBRE as usuario,
             cr.NOMBRE_CURSO as curso,
             c.FECHACOMPRA as fecha,
             cr.PRECIO as monto,
             'Completada' as estado
        FROM carrito c
        JOIN usuario u ON c.ID_USUARIO = u.ID_USUARIO
        JOIN curso cr ON c.ID_CURSO = cr.ID_CURSO
        JOIN comprobante cp ON c.ID_CARRITO = cp.ID_CARRITO
        ORDER BY c.FECHACOMPRA DESC
      `, (err, results) => {
        if (err) return reject(err);
        resolve(results);
      });
    });

    res.render("admin", {
      admin: req.session.usuario,
      stats,
      usuarios,
      cursos,
      ventas
    });
  } catch (error) {
    console.error('Error en panel de administraciÃ³n:', error);
    res.status(500).send('Error al cargar el panel de administraciÃ³n');
  }
});

// API para gestiÃ³n de usuarios
app.post("/api/usuarios", verificarAdmin, async (req, res) => {
    try {
        const { nombre, email, rol, password } = req.body;
        const dni = Math.floor(Math.random() * 100000000).toString(); // DNI temporal
        const hash = await bcrypt.hash(password, 10);

        // Insertar en persona
        await new Promise((resolve, reject) => {
            conexion.query('INSERT INTO persona (DNI, NOMBRE, EMAIL) VALUES (?, ?, ?)',
                [dni, nombre, email],
                (err) => err ? reject(err) : resolve()
            );
        });

        // Insertar en usuario
        await new Promise((resolve, reject) => {
            conexion.query('INSERT INTO usuario (DNI, NOMBRE, CONTRASENIA) VALUES (?, ?, ?)',
                [dni, email, hash],
                async (err, result) => {
                    if (err) return reject(err);
                    // Si el rol es admin, agregar a la tabla ADMINISTRADOR
                    if (rol === 'admin') {
                        conexion.query('INSERT INTO ADMINISTRADOR (ID_USUARIO) VALUES (?)',
                            [result.insertId],
                            (err) => err ? reject(err) : resolve()
                        );
                    } else {
                        resolve();
                    }
                }
            );
        });

        res.json({ success: true });
    } catch (error) {
        console.error('Error al crear usuario:', error);
        res.status(500).json({ error: 'Error al crear usuario' });
    }
});

app.put("/api/usuarios/:id", verificarAdmin, async (req, res) => {
    try {
        const { nombre, email, rol } = req.body;
        const id = req.params.id;

        // Actualizar usuario y persona
        await new Promise((resolve, reject) => {
            conexion.query(`
                UPDATE usuario u 
                JOIN persona p ON u.DNI = p.DNI 
                SET u.NOMBRE = ?, p.EMAIL = ?
                WHERE u.ID_USUARIO = ?`,
                [nombre, email, id],
                async (err) => {
                    if (err) return reject(err);
                    
                    // Manejar el cambio de rol
                    if (rol === 'admin') {
                        // Insertar en ADMINISTRADOR si no existe
                        conexion.query('INSERT IGNORE INTO ADMINISTRADOR (ID_USUARIO) VALUES (?)',
                            [id],
                            (err) => err ? reject(err) : resolve()
                        );
                    } else {
                        // Eliminar de ADMINISTRADOR si existe
                        conexion.query('DELETE FROM ADMINISTRADOR WHERE ID_USUARIO = ?',
                            [id],
                            (err) => err ? reject(err) : resolve()
                        );
                    }
                }
            );
        });

        res.json({ success: true });
    } catch (error) {
        console.error('Error al actualizar usuario:', error);
        res.status(500).json({ error: 'Error al actualizar usuario' });
    }
});

app.delete("/api/usuarios/:id", verificarAdmin, async (req, res) => {
    try {
        const id = req.params.id;
        await new Promise((resolve, reject) => {
            conexion.query('DELETE FROM usuario WHERE ID_USUARIO = ?',
                [id],
                (err) => err ? reject(err) : resolve()
            );
        });

        res.json({ success: true });
    } catch (error) {
        console.error('Error al eliminar usuario:', error);
        res.status(500).json({ error: 'Error al eliminar usuario' });
    }
});

// API para gestiÃ³n de cursos
app.post("/api/cursos", verificarAdmin, async (req, res) => {
  try {
    const { nombreCurso, precio, descripcion, estado, urlVideo } = req.body;
    await new Promise((resolve, reject) => {
      conexion.query('INSERT INTO curso (NOMBRE_CURSO, PRECIO, DESCRIPCION, URL_VIDEO) VALUES (?, ?, ?, ?)',
        [nombreCurso, precio, descripcion, urlVideo || ''],
        (err) => err ? reject(err) : resolve()
      );
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error al crear curso:', error);
    res.status(500).json({ error: 'Error al crear curso' });
  }
});

app.put("/api/cursos/:id", verificarAdmin, async (req, res) => {
  try {
    const { nombreCurso, precio, descripcion, estado, urlVideo } = req.body;
    const id = req.params.id;

    await new Promise((resolve, reject) => {
      conexion.query(`
        UPDATE curso 
        SET NOMBRE_CURSO = ?, PRECIO = ?, DESCRIPCION = ?, URL_VIDEO = ?
        WHERE ID_CURSO = ?`,
        [nombreCurso, precio, descripcion, urlVideo || '', id],
        (err) => err ? reject(err) : resolve()
      );
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error al actualizar curso:', error);
    res.status(500).json({ error: 'Error al actualizar curso' });
  }
});

app.delete("/api/cursos/:id", verificarAdmin, async (req, res) => {
    try {
        const id = req.params.id;
        await new Promise((resolve, reject) => {
            conexion.query('DELETE FROM curso WHERE ID_CURSO = ?',
                [id],
                (err) => err ? reject(err) : resolve()
            );
        });

        res.json({ success: true });
    } catch (error) {
        console.error('Error al eliminar curso:', error);
        res.status(500).json({ error: 'Error al eliminar curso' });
    }
});

// ----------------- Servidor -----------------
http.createServer(app).listen(PORT, () => {
  console.log("ðŸš€ Servidor activo en puerto " + PORT);
});

